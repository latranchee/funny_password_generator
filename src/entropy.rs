//! Entropy estimation for generated passwords.
//!
//! This module calculates the approximate entropy (bits of randomness) in passwords
//! generated by the funny password generator. The entropy accounts for:
//! - The number of possible words in each category
//! - The branching factor at each transition point (weighted by probability)

use crate::transitions::{get_transitions, Category, Transition};
use crate::words::*;

/// Represents the entropy contribution from a single step in password generation.
#[derive(Debug)]
pub struct EntropyStep {
    pub category: Category,
    pub word_entropy: f64,
    pub transition_entropy: f64,
}

/// Get the word count for a category, accounting for NSFW mode.
fn get_category_word_count(category: Category, nsfw: bool) -> usize {
    match category {
        Category::Adjective => get_adjectives(nsfw).len(),
        Category::Profession => get_professions(nsfw).len(),
        Category::Noun => get_nouns(nsfw).len(),
        Category::Object => get_objects(nsfw).len(),
        Category::Adverb => get_adverbs(nsfw).len(),
        Category::Gerund => get_gerunds(nsfw).len(),
        Category::PresentVerb => get_present_verbs(nsfw).len(),
        // These categories don't have NSFW variants
        _ => category.words().len(),
    }
}

/// Calculate the entropy (in bits) for a sequence of categories.
///
/// The total entropy is the sum of:
/// 1. Word selection entropy: log2(number of words in category) for each word
/// 2. Transition entropy: weighted entropy of choosing the next category
pub fn calculate_entropy(categories: &[Category]) -> f64 {
    calculate_entropy_with_nsfw(categories, false)
}

/// Calculate the entropy (in bits) for a sequence of categories, with NSFW mode.
///
/// The total entropy is the sum of:
/// 1. Word selection entropy: log2(number of words in category) for each word
/// 2. Transition entropy: weighted entropy of choosing the next category
pub fn calculate_entropy_with_nsfw(categories: &[Category], nsfw: bool) -> f64 {
    let mut total_entropy = 0.0;
    let mut prev_category: Option<Category> = None;

    for &category in categories {
        // Add transition entropy (branching factor at this decision point)
        let transitions = get_transitions(prev_category);
        let transition_entropy = calculate_transition_entropy(transitions, category);
        total_entropy += transition_entropy;

        // Add word selection entropy (accounting for NSFW mode)
        let word_count = get_category_word_count(category, nsfw);
        if word_count > 0 {
            let word_entropy = (word_count as f64).log2();
            total_entropy += word_entropy;
        }

        prev_category = Some(category);
    }

    total_entropy
}

/// Calculate the entropy contribution from a transition choice.
///
/// This uses Shannon entropy: -sum(p * log2(p)) for each possible transition,
/// but since we made a specific choice, we use -log2(p) for the chosen transition.
/// This represents the "surprise" or information content of making that choice.
fn calculate_transition_entropy(transitions: &[Transition], chosen: Category) -> f64 {
    if transitions.is_empty() {
        return 0.0;
    }

    let total_weight: u32 = transitions.iter().map(|t| t.weight).sum();
    if total_weight == 0 {
        return 0.0;
    }

    // Find the weight of the chosen category
    let chosen_weight = transitions
        .iter()
        .find(|t| t.category == chosen)
        .map(|t| t.weight)
        .unwrap_or(0);

    if chosen_weight == 0 {
        // Chosen category wasn't in the transitions (e.g., forced extension)
        // In this case, there was no randomness in the choice
        return 0.0;
    }

    // Entropy contribution: -log2(probability) = log2(total/chosen)
    let probability = chosen_weight as f64 / total_weight as f64;
    -probability.log2()
}

/// Parse a password string back into categories for entropy estimation.
///
/// This is an approximate reverse-engineering of the generation process.
/// It identifies words and maps them back to their likely categories.
pub fn estimate_categories_from_password(password: &str) -> Vec<Category> {
    use crate::words::*;

    let words: Vec<&str> = password.split_whitespace().collect();
    let mut categories = Vec::new();

    for word in words {
        // Handle "an" as an article (it was converted from "a")
        let normalized = if word == "an" { "a" } else { word };

        let category = if ARTICLES.contains(&normalized) {
            Category::Article
        } else if ADJECTIVES.contains(&word) {
            Category::Adjective
        } else if ANIMALS.contains(&word) {
            Category::Animal
        } else if PROFESSIONS.contains(&word) {
            Category::Profession
        } else if NOUNS.contains(&word) {
            Category::Noun
        } else if GERUNDS.contains(&word) {
            Category::Gerund
        } else if PRESENT_VERBS.contains(&word) {
            Category::PresentVerb
        } else if OBJECTS.contains(&word) {
            Category::Object
        } else if ADVERBS.contains(&word) {
            Category::Adverb
        } else if PREPOSITIONS.contains(&word) {
            Category::Preposition
        } else if CONNECTORS.contains(&word) {
            Category::Connector
        } else {
            // Unknown word - skip it for entropy calculation
            continue;
        };

        categories.push(category);
    }

    categories
}

/// Estimate the entropy of a generated password string.
///
/// Returns the approximate entropy in bits.
pub fn estimate_password_entropy(password: &str) -> f64 {
    let categories = estimate_categories_from_password(password);
    calculate_entropy(&categories)
}

/// Estimate the entropy from a vector of words (as generated by generate_password).
///
/// Returns the approximate entropy in bits.
pub fn estimate_entropy_from_words(words: &[String]) -> f64 {
    estimate_entropy_from_words_with_nsfw(words, false)
}

/// Estimate the entropy from a vector of words, with NSFW mode.
///
/// Returns the approximate entropy in bits.
pub fn estimate_entropy_from_words_with_nsfw(words: &[String], nsfw: bool) -> f64 {
    let categories = estimate_categories_from_words_with_nsfw(words, nsfw);
    calculate_entropy_with_nsfw(&categories, nsfw)
}

/// Parse a vector of words into categories for entropy estimation.
fn estimate_categories_from_words(words: &[String]) -> Vec<Category> {
    estimate_categories_from_words_with_nsfw(words, false)
}

/// Parse a vector of words into categories for entropy estimation, with NSFW mode.
fn estimate_categories_from_words_with_nsfw(words: &[String], nsfw: bool) -> Vec<Category> {
    let mut categories = Vec::new();

    // Get word lists (with NSFW if enabled)
    let adjectives = get_adjectives(nsfw);
    let professions = get_professions(nsfw);
    let nouns = get_nouns(nsfw);
    let gerunds = get_gerunds(nsfw);
    let present_verbs = get_present_verbs(nsfw);
    let objects = get_objects(nsfw);
    let adverbs = get_adverbs(nsfw);

    for word in words {
        let word_str = word.as_str();
        // Handle "an" as an article (it was converted from "a")
        let normalized = if word_str == "an" { "a" } else { word_str };

        let category = if ARTICLES.contains(&normalized) {
            Category::Article
        } else if adjectives.contains(&word_str) {
            Category::Adjective
        } else if ANIMALS.contains(&word_str) {
            Category::Animal
        } else if professions.contains(&word_str) {
            Category::Profession
        } else if nouns.contains(&word_str) {
            Category::Noun
        } else if gerunds.contains(&word_str) {
            Category::Gerund
        } else if present_verbs.contains(&word_str) {
            Category::PresentVerb
        } else if objects.contains(&word_str) {
            Category::Object
        } else if adverbs.contains(&word_str) {
            Category::Adverb
        } else if PREPOSITIONS.contains(&word_str) {
            Category::Preposition
        } else if CONNECTORS.contains(&word_str) {
            Category::Connector
        } else {
            // Unknown word - skip it for entropy calculation
            continue;
        };

        categories.push(category);
    }

    categories
}

/// Format the entropy as a human-readable string.
pub fn format_entropy(entropy: f64) -> String {
    format!("~{:.0} bits", entropy)
}

/// Estimate time to crack based on entropy bits
/// Shows time for different attack scenarios
pub fn estimate_crack_time(entropy_bits: f64) -> String {
    let combinations = 2_f64.powf(entropy_bits);

    // Attack scenarios (guesses per second):
    // - Online (rate-limited): 1,000/s
    // - Offline (fast hash like MD5): 10 billion/s
    // - Offline (slow hash like bcrypt): 10,000/s

    // Use offline slow hash as reasonable estimate
    let guesses_per_second = 10_000.0;
    let seconds = combinations / guesses_per_second / 2.0; // Average case = half

    format_duration(seconds)
}

/// Calculate brute force entropy based on character set and length.
/// Assumes attacker tries every possible character combination.
pub fn calculate_bruteforce_entropy(password: &str) -> f64 {
    let len = password.len() as f64;

    // Determine character set size based on what's in the password
    let has_lower = password.chars().any(|c| c.is_ascii_lowercase());
    let has_upper = password.chars().any(|c| c.is_ascii_uppercase());
    let has_digit = password.chars().any(|c| c.is_ascii_digit());
    let has_space = password.contains(' ');
    let has_special = password.chars().any(|c| {
        !c.is_ascii_alphanumeric() && c != ' '
    });

    let mut charset_size = 0u32;
    if has_lower { charset_size += 26; }
    if has_upper { charset_size += 26; }
    if has_digit { charset_size += 10; }
    if has_space { charset_size += 1; }
    if has_special { charset_size += 32; } // Common special chars

    // Minimum charset assumption (lowercase + space for passphrases)
    if charset_size == 0 {
        charset_size = 27;
    }

    len * (charset_size as f64).log2()
}

/// Estimate brute force crack time based on password string.
pub fn estimate_bruteforce_crack_time(password: &str) -> String {
    let entropy = calculate_bruteforce_entropy(password);
    estimate_crack_time(entropy)
}

/// Calculate entropy from formatting choices applied during password display.
/// This accounts for random elements added in format_password():
/// - Dramatic openers (25% chance, 30 options × 2 punctuation = 60 total)
/// - Air quotes on adjectives (30% chance per adjective)
/// - Smart punctuation (1-3 options depending on sentence type)
/// - Article prefix for adjective-starting passwords (The/A/An)
pub fn calculate_formatting_entropy(password: &str, adjective_count: usize) -> f64 {
    let mut entropy = 0.0;

    // Dramatic openers: 25% chance of appearing
    // If present: 30 words × 2 punctuation = 60 options
    // Entropy = P(opener) × log2(60) + P(no opener) × 0
    // Using weighted average: 0.25 × log2(60) ≈ 1.47 bits average contribution
    // But we detect if one is present to give accurate entropy
    const OPENERS: &[&str] = &[
        "Beware", "Listen", "Warning", "Attention", "Alert",
        "Behold", "Alas", "Indeed", "Clearly", "Obviously",
        "Seriously", "Honestly", "Tragically", "Surprisingly",
        "Allegedly", "Reportedly", "Shockingly", "Naturally",
        "Curiously", "Mysteriously", "Suspiciously", "Frankly",
        "Incredibly", "Absurdly", "Hilariously", "Sadly",
        "Fortunately", "Unfortunately", "Remarkably", "Notably",
    ];

    let has_opener = OPENERS.iter().any(|&opener| {
        password.starts_with(opener) || password.starts_with(&opener.to_lowercase())
    });

    if has_opener {
        // Opener present: log2(30 words × 2 punctuation) + log2(1/0.25) for the choice to add it
        entropy += (30.0_f64 * 2.0).log2(); // ~5.9 bits for which opener
        entropy += (1.0 / 0.25_f64).log2(); // ~2 bits for choosing to have opener
    } else {
        // No opener: log2(1/0.75) for the choice not to add it
        entropy += (1.0 / 0.75_f64).log2(); // ~0.42 bits
    }

    // Air quotes: 30% chance per adjective
    // Each adjective with quotes: log2(1/0.3) ≈ 1.74 bits
    // Each adjective without quotes: log2(1/0.7) ≈ 0.51 bits
    let quoted_adjectives = password.matches('"').count() / 2; // pairs of quotes
    let unquoted_adjectives = adjective_count.saturating_sub(quoted_adjectives);

    if quoted_adjectives > 0 {
        entropy += quoted_adjectives as f64 * (1.0 / 0.3_f64).log2();
    }
    if unquoted_adjectives > 0 {
        entropy += unquoted_adjectives as f64 * (1.0 / 0.7_f64).log2();
    }

    // Punctuation entropy (detecting which was used)
    let ends_with_question = password.ends_with('?');
    let ends_with_exclaim = password.ends_with('!');
    let ends_with_ellipsis = password.ends_with("...");
    let ends_with_period = password.ends_with('.') && !ends_with_ellipsis;

    // Questions always get "?" - 0 bits (deterministic)
    // Imperatives/warnings get "!" or "..." - 1 bit
    // Statements get ".", "!", or "..." - ~1.58 bits
    if ends_with_question {
        // Deterministic, no entropy
    } else if ends_with_exclaim || ends_with_ellipsis {
        // Could be imperative (2 options) or statement (3 options)
        // Conservative estimate: assume 2-3 options average
        entropy += 1.0; // ~1 bit
    } else if ends_with_period {
        // Statement with period (1 of 3 options)
        entropy += (3.0_f64).log2(); // ~1.58 bits
    }

    // Article prefix for adjective-starting passwords
    // The (70%), A (15%), An (15%) - but only when first word is adjective
    // Entropy ≈ -0.7×log2(0.7) - 0.15×log2(0.15) - 0.15×log2(0.15) ≈ 1.18 bits
    // We detect this by checking if password starts with "The ", "A ", or "An "
    if password.starts_with("The ") || password.starts_with("A ") || password.starts_with("An ") {
        // Check if this was an added article (not part of original template)
        // by seeing if second word looks like an adjective
        let words: Vec<&str> = password.split_whitespace().collect();
        if words.len() > 1 {
            let second_word = words[1].trim_matches('"').to_lowercase();
            if get_adjectives(false).contains(&second_word.as_str()) {
                // Article was likely added - account for The(70%)/A/An(30%) choice
                entropy += 1.2; // approximate weighted entropy
            }
        }
    }

    entropy
}

fn format_duration(seconds: f64) -> String {
    const SECONDS_PER_YEAR: f64 = 31536000.0;
    const UNIVERSE_AGE_YEARS: f64 = 13.8e9; // ~13.8 billion years

    if seconds < 1.0 {
        "instant".to_string()
    } else if seconds < 60.0 {
        format!("{:.0} seconds", seconds)
    } else if seconds < 3600.0 {
        format!("{:.0} minutes", seconds / 60.0)
    } else if seconds < 86400.0 {
        format!("{:.1} hours", seconds / 3600.0)
    } else if seconds < SECONDS_PER_YEAR {
        format!("{:.0} days", seconds / 86400.0)
    } else if seconds < SECONDS_PER_YEAR * 1000.0 {
        format!("{:.0} years", seconds / SECONDS_PER_YEAR)
    } else if seconds < SECONDS_PER_YEAR * 1_000_000.0 {
        format!("{:.0} thousand years", seconds / SECONDS_PER_YEAR / 1000.0)
    } else if seconds < SECONDS_PER_YEAR * 1_000_000_000.0 {
        format!("{:.0} million years", seconds / SECONDS_PER_YEAR / 1_000_000.0)
    } else if seconds < SECONDS_PER_YEAR * 1_000_000_000_000.0 {
        format!("{:.0} billion years", seconds / SECONDS_PER_YEAR / 1_000_000_000.0)
    } else if seconds < SECONDS_PER_YEAR * UNIVERSE_AGE_YEARS * 1000.0 {
        let universe_multiples = seconds / SECONDS_PER_YEAR / UNIVERSE_AGE_YEARS;
        format!("{:.0}x age of universe", universe_multiples)
    } else {
        "heat death of universe".to_string()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_single_category_entropy() {
        // Just an article (2 choices = 1 bit of word entropy, plus transition)
        let categories = vec![Category::Article];
        let entropy = calculate_entropy(&categories);
        // Article has 2 words = 1 bit, start->article is 100% = 0 bits
        assert!((entropy - 1.0).abs() < 0.01);
    }

    #[test]
    fn test_entropy_estimation_roundtrip() {
        let password = "the grumpy walrus juggles pickles";
        let categories = estimate_categories_from_password(password);
        assert_eq!(categories.len(), 5);
        assert_eq!(categories[0], Category::Article);
        assert_eq!(categories[1], Category::Adjective);
        assert_eq!(categories[2], Category::Animal);
        assert_eq!(categories[3], Category::PresentVerb);
        assert_eq!(categories[4], Category::Object);
    }

    #[test]
    fn test_format_entropy() {
        assert_eq!(format_entropy(45.7), "~46 bits");
        assert_eq!(format_entropy(32.2), "~32 bits");
    }
}
