//! Entropy estimation for generated passwords.
//!
//! This module calculates the approximate entropy (bits of randomness) in passwords
//! generated by the funny password generator. The entropy accounts for:
//! - The number of possible words in each category
//! - The branching factor at each transition point (weighted by probability)

use crate::transitions::{get_transitions, Category, Transition};
use crate::words::*;

/// Represents the entropy contribution from a single step in password generation.
#[derive(Debug)]
pub struct EntropyStep {
    pub category: Category,
    pub word_entropy: f64,
    pub transition_entropy: f64,
}

/// Get the word count for a category, accounting for NSFW mode.
fn get_category_word_count(category: Category, nsfw: bool) -> usize {
    match category {
        Category::Adjective => get_adjectives(nsfw).len(),
        Category::Profession => get_professions(nsfw).len(),
        Category::Noun => get_nouns(nsfw).len(),
        Category::Object => get_objects(nsfw).len(),
        Category::Adverb => get_adverbs(nsfw).len(),
        Category::Gerund => get_gerunds(nsfw).len(),
        Category::PresentVerb => get_present_verbs(nsfw).len(),
        // These categories don't have NSFW variants
        _ => category.words().len(),
    }
}

/// Calculate the entropy (in bits) for a sequence of categories.
///
/// The total entropy is the sum of:
/// 1. Word selection entropy: log2(number of words in category) for each word
/// 2. Transition entropy: weighted entropy of choosing the next category
pub fn calculate_entropy(categories: &[Category]) -> f64 {
    calculate_entropy_with_nsfw(categories, false)
}

/// Calculate the entropy (in bits) for a sequence of categories, with NSFW mode.
///
/// The total entropy is the sum of:
/// 1. Word selection entropy: log2(number of words in category) for each word
/// 2. Transition entropy: weighted entropy of choosing the next category
pub fn calculate_entropy_with_nsfw(categories: &[Category], nsfw: bool) -> f64 {
    let mut total_entropy = 0.0;
    let mut prev_category: Option<Category> = None;

    for &category in categories {
        // Add transition entropy (branching factor at this decision point)
        let transitions = get_transitions(prev_category);
        let transition_entropy = calculate_transition_entropy(transitions, category);
        total_entropy += transition_entropy;

        // Add word selection entropy (accounting for NSFW mode)
        let word_count = get_category_word_count(category, nsfw);
        if word_count > 0 {
            let word_entropy = (word_count as f64).log2();
            total_entropy += word_entropy;
        }

        prev_category = Some(category);
    }

    total_entropy
}

/// Calculate the entropy contribution from a transition choice.
///
/// This uses Shannon entropy: -sum(p * log2(p)) for each possible transition,
/// but since we made a specific choice, we use -log2(p) for the chosen transition.
/// This represents the "surprise" or information content of making that choice.
fn calculate_transition_entropy(transitions: &[Transition], chosen: Category) -> f64 {
    if transitions.is_empty() {
        return 0.0;
    }

    let total_weight: u32 = transitions.iter().map(|t| t.weight).sum();
    if total_weight == 0 {
        return 0.0;
    }

    // Find the weight of the chosen category
    let chosen_weight = transitions
        .iter()
        .find(|t| t.category == chosen)
        .map(|t| t.weight)
        .unwrap_or(0);

    if chosen_weight == 0 {
        // Chosen category wasn't in the transitions (e.g., forced extension)
        // In this case, there was no randomness in the choice
        return 0.0;
    }

    // Entropy contribution: -log2(probability) = log2(total/chosen)
    let probability = chosen_weight as f64 / total_weight as f64;
    -probability.log2()
}

/// Parse a password string back into categories for entropy estimation.
///
/// This is an approximate reverse-engineering of the generation process.
/// It identifies words and maps them back to their likely categories.
pub fn estimate_categories_from_password(password: &str) -> Vec<Category> {
    use crate::words::*;

    let words: Vec<&str> = password.split_whitespace().collect();
    let mut categories = Vec::new();

    for word in words {
        // Handle "an" as an article (it was converted from "a")
        let normalized = if word == "an" { "a" } else { word };

        let category = if ARTICLES.contains(&normalized) {
            Category::Article
        } else if ADJECTIVES.contains(&word) {
            Category::Adjective
        } else if ANIMALS.contains(&word) {
            Category::Animal
        } else if PROFESSIONS.contains(&word) {
            Category::Profession
        } else if NOUNS.contains(&word) {
            Category::Noun
        } else if GERUNDS.contains(&word) {
            Category::Gerund
        } else if PRESENT_VERBS.contains(&word) {
            Category::PresentVerb
        } else if OBJECTS.contains(&word) {
            Category::Object
        } else if ADVERBS.contains(&word) {
            Category::Adverb
        } else if PREPOSITIONS.contains(&word) {
            Category::Preposition
        } else if CONNECTORS.contains(&word) {
            Category::Connector
        } else {
            // Unknown word - skip it for entropy calculation
            continue;
        };

        categories.push(category);
    }

    categories
}

/// Estimate the entropy of a generated password string.
///
/// Returns the approximate entropy in bits.
pub fn estimate_password_entropy(password: &str) -> f64 {
    let categories = estimate_categories_from_password(password);
    calculate_entropy(&categories)
}

/// Estimate the entropy from a vector of words (as generated by generate_password).
///
/// Returns the approximate entropy in bits.
pub fn estimate_entropy_from_words(words: &[String]) -> f64 {
    estimate_entropy_from_words_with_nsfw(words, false)
}

/// Estimate the entropy from a vector of words, with NSFW mode.
///
/// Returns the approximate entropy in bits.
pub fn estimate_entropy_from_words_with_nsfw(words: &[String], nsfw: bool) -> f64 {
    let categories = estimate_categories_from_words_with_nsfw(words, nsfw);
    calculate_entropy_with_nsfw(&categories, nsfw)
}

/// Parse a vector of words into categories for entropy estimation.
fn estimate_categories_from_words(words: &[String]) -> Vec<Category> {
    estimate_categories_from_words_with_nsfw(words, false)
}

/// Parse a vector of words into categories for entropy estimation, with NSFW mode.
fn estimate_categories_from_words_with_nsfw(words: &[String], nsfw: bool) -> Vec<Category> {
    let mut categories = Vec::new();

    // Get word lists (with NSFW if enabled)
    let adjectives = get_adjectives(nsfw);
    let professions = get_professions(nsfw);
    let nouns = get_nouns(nsfw);
    let gerunds = get_gerunds(nsfw);
    let present_verbs = get_present_verbs(nsfw);
    let objects = get_objects(nsfw);
    let adverbs = get_adverbs(nsfw);

    for word in words {
        let word_str = word.as_str();
        // Handle "an" as an article (it was converted from "a")
        let normalized = if word_str == "an" { "a" } else { word_str };

        let category = if ARTICLES.contains(&normalized) {
            Category::Article
        } else if adjectives.contains(&word_str) {
            Category::Adjective
        } else if ANIMALS.contains(&word_str) {
            Category::Animal
        } else if professions.contains(&word_str) {
            Category::Profession
        } else if nouns.contains(&word_str) {
            Category::Noun
        } else if gerunds.contains(&word_str) {
            Category::Gerund
        } else if present_verbs.contains(&word_str) {
            Category::PresentVerb
        } else if objects.contains(&word_str) {
            Category::Object
        } else if adverbs.contains(&word_str) {
            Category::Adverb
        } else if PREPOSITIONS.contains(&word_str) {
            Category::Preposition
        } else if CONNECTORS.contains(&word_str) {
            Category::Connector
        } else {
            // Unknown word - skip it for entropy calculation
            continue;
        };

        categories.push(category);
    }

    categories
}

/// Format the entropy as a human-readable string.
pub fn format_entropy(entropy: f64) -> String {
    format!("~{:.0} bits", entropy)
}

/// Estimate time to crack based on entropy bits
/// Shows time for different attack scenarios
pub fn estimate_crack_time(entropy_bits: f64) -> String {
    let combinations = 2_f64.powf(entropy_bits);

    // Attack scenarios (guesses per second):
    // - Online (rate-limited): 1,000/s
    // - Offline (fast hash like MD5): 10 billion/s
    // - Offline (slow hash like bcrypt): 10,000/s

    // Use offline slow hash as reasonable estimate
    let guesses_per_second = 10_000.0;
    let seconds = combinations / guesses_per_second / 2.0; // Average case = half

    format_duration(seconds)
}

/// Calculate brute force entropy based on character set and length.
/// Assumes attacker tries every possible character combination.
pub fn calculate_bruteforce_entropy(password: &str) -> f64 {
    let len = password.len() as f64;

    // Determine character set size based on what's in the password
    let has_lower = password.chars().any(|c| c.is_ascii_lowercase());
    let has_upper = password.chars().any(|c| c.is_ascii_uppercase());
    let has_digit = password.chars().any(|c| c.is_ascii_digit());
    let has_space = password.contains(' ');
    let has_special = password.chars().any(|c| {
        !c.is_ascii_alphanumeric() && c != ' '
    });

    let mut charset_size = 0u32;
    if has_lower { charset_size += 26; }
    if has_upper { charset_size += 26; }
    if has_digit { charset_size += 10; }
    if has_space { charset_size += 1; }
    if has_special { charset_size += 32; } // Common special chars

    // Minimum charset assumption (lowercase + space for passphrases)
    if charset_size == 0 {
        charset_size = 27;
    }

    len * (charset_size as f64).log2()
}

/// Estimate brute force crack time based on password string.
pub fn estimate_bruteforce_crack_time(password: &str) -> String {
    let entropy = calculate_bruteforce_entropy(password);
    estimate_crack_time(entropy)
}

fn format_duration(seconds: f64) -> String {
    const SECONDS_PER_YEAR: f64 = 31536000.0;
    const UNIVERSE_AGE_YEARS: f64 = 13.8e9; // ~13.8 billion years

    if seconds < 1.0 {
        "instant".to_string()
    } else if seconds < 60.0 {
        format!("{:.0} seconds", seconds)
    } else if seconds < 3600.0 {
        format!("{:.0} minutes", seconds / 60.0)
    } else if seconds < 86400.0 {
        format!("{:.1} hours", seconds / 3600.0)
    } else if seconds < SECONDS_PER_YEAR {
        format!("{:.0} days", seconds / 86400.0)
    } else if seconds < SECONDS_PER_YEAR * 1000.0 {
        format!("{:.0} years", seconds / SECONDS_PER_YEAR)
    } else if seconds < SECONDS_PER_YEAR * 1_000_000.0 {
        format!("{:.0} thousand years", seconds / SECONDS_PER_YEAR / 1000.0)
    } else if seconds < SECONDS_PER_YEAR * 1_000_000_000.0 {
        format!("{:.0} million years", seconds / SECONDS_PER_YEAR / 1_000_000.0)
    } else if seconds < SECONDS_PER_YEAR * 1_000_000_000_000.0 {
        format!("{:.0} billion years", seconds / SECONDS_PER_YEAR / 1_000_000_000.0)
    } else if seconds < SECONDS_PER_YEAR * UNIVERSE_AGE_YEARS * 1000.0 {
        let universe_multiples = seconds / SECONDS_PER_YEAR / UNIVERSE_AGE_YEARS;
        format!("{:.0}x age of universe", universe_multiples)
    } else {
        "heat death of universe".to_string()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_single_category_entropy() {
        // Just an article (2 choices = 1 bit of word entropy, plus transition)
        let categories = vec![Category::Article];
        let entropy = calculate_entropy(&categories);
        // Article has 2 words = 1 bit, start->article is 100% = 0 bits
        assert!((entropy - 1.0).abs() < 0.01);
    }

    #[test]
    fn test_entropy_estimation_roundtrip() {
        let password = "the grumpy walrus juggles pickles";
        let categories = estimate_categories_from_password(password);
        assert_eq!(categories.len(), 5);
        assert_eq!(categories[0], Category::Article);
        assert_eq!(categories[1], Category::Adjective);
        assert_eq!(categories[2], Category::Animal);
        assert_eq!(categories[3], Category::PresentVerb);
        assert_eq!(categories[4], Category::Object);
    }

    #[test]
    fn test_format_entropy() {
        assert_eq!(format_entropy(45.7), "~46 bits");
        assert_eq!(format_entropy(32.2), "~32 bits");
    }
}
